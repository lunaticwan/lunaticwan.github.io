# 10장: 부분 프리렌더링 (선택 사항) - Partial Prerendering (Optional)

> 부분 프리렌더링은 Next.js 14에서 도입된 실험적인 기능입니다. 이 기능의 안정성이 발전함에 따라 이 페이지의 내용이 업데이트될 수 있습니다. 실험적인 기능을 사용하고 싶지 않다면 이 장을 건너뛰는 것이 좋습니다. 이 장은 과정을 완료하는 데 필수적이지 않습니다.

이 장에서는...

다룰 주제들입니다.

- 부분 프리렌더링이 무엇인지.
- 부분 프리렌더링이 어떻게 작동하는지.

---

## 정적 및 동적 콘텐츠 결합 - Combining Static and Dynamic Content

현재, 라우트 내에서 **동적 함수**(`noStore()`, `cookies()` 등)를 호출하면, 해당 라우트 전체가 동적이 됩니다.

> <https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-functions>

오늘날 대부분의 웹 앱은 이렇게 구축됩니다. **전체 애플리케이션** 또는 **특정 라우트**에 대해 정적 또는 동적 렌더링 중에서 선택합니다.

그러나 대부분의 라우트는 완전히 정적이거나 동적이지 않습니다. 정적 및 동적 콘텐츠가 모두 있는 라우트가 있을 수 있습니다. 예를 들어, **전자상거래 사이트**를 생각해보세요. 제품 페이지의 대부분을 프리렌더링할 수 있지만, 사용자의 카트와 추천 제품을 동적으로 온디맨드로 가져오고 싶을 수 있습니다.

> <https://partialprerendering.com/>

대시보드 페이지로 돌아가서, 어떤 컴포넌트를 정적 또는 동적으로 고려하겠습니까?

![/assets/Learn_Nextjs/image_url__2Flearn_2Flight_2Fdas_6a757dc8de104448a.png](/assets/Learn_Nextjs/image_url__2Flearn_2Flight_2Fdas_6a757dc8de104448a.png)

- `<SideNav>` 컴포넌트는 데이터에 의존하지 않고 사용자에게 개인화되지 않으므로 **정적**일 수 있습니다.
- `<Page>` 내의 컴포넌트들은 자주 변경되는 데이터에 의존하며 사용자에게 개인화될 것이므로 **동적**일 수 있습니다.

---

## 부분 프리렌더링이란? - What is Partial Prerendering?

Next.js 14에는 **부분 프리렌더링**의 프리뷰가 포함되어 있습니다 – 정적 로딩 쉘로 라우트를 렌더링하면서 일부 부분을 동적으로 유지할 수 있는 실험적 기능입니다. 즉, 라우트의 동적 부분을 분리할 수 있습니다. 예를 들어:

![/assets/Learn_Nextjs/image_url__2Flearn_2Flight_2Fthi_9eec3739d6f74ecbb.png](/assets/Learn_Nextjs/image_url__2Flearn_2Flight_2Fthi_9eec3739d6f74ecbb.png)

사용자가 라우트를 방문할 때:

- 정적 라우트 쉘이 제공되어 빠른 초기 로드를 보장합니다.
- 쉘은 동적 콘텐츠가 비동기적으로 로드될 곳을 남깁니다.
- 비동기적으로 채워지는 부분은 병렬로 스트리밍되어 페이지의 전체 로드 시간을 줄입니다.

이는 오늘날 여러분의 애플리케이션이 작동하는 방식과 다릅니다. 여기서 전체 라우트는 완전히 정적이거나 동적입니다.

부분 프리렌더링은 초고속 정적 엣지 배달과 완전히 동적인 기능을 결합하며, 정적 사이트 생성과 동적 배달의 최고의 요소를 결합하여 **웹 애플리케이션의 기본 렌더링 모델이 될 잠재력**을 가지고 있다고 믿습니다.

> <https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model>

---

## 부분 프리렌더링은 어떻게 작동하나요? - How does Partial Prerendering work?

부분 프리렌더링은 React의 **Concurrent APIs**를 활용하고 **Suspense**를 사용하여 애플리케이션의 일부를 조건이 충족될 때까지 렌더링을 연기합니다(예: 데이터가 로드됨).

> <https://react.dev/blog/2021/12/17/react-conf-2021-recap#react-18-and-concurrent-features> > <https://react.dev/reference/react/Suspense>

초기 정적 파일에는 다른 정적 콘텐츠와 함께 대체 내용이 포함됩니다. 빌드 시간(또는 재검증 시)에, 라우트의 정적 부분은 *프리렌더링*되고, 나머지는 사용자가 라우트를 요청할 때까지 **연기됩니다**.

Suspense를 컴포넌트에 적용하는 것이 컴포넌트 자체를 동적으로 만들지는 않습니다(이 동작을 달성하기 위해 `unstable_noStore`를 사용했음을 기억하세요), 하지만 Suspense는 라우트의 정적 부분과 동적 부분 사이의 경계로 사용됩니다.

부분 프리렌더링의 좋은 점은 이를 사용하기 위해 코드를 변경할 필요가 없다는 것입니다. 라우트의 동적 부분을 감싸는 데 Suspense를 사용하는 한, Next.js는 라우트의 어떤 부분이 정적이고 어떤 부분이 동적인지 알 수 있습니다.

> **참고:** 부분 프리렌더링을 구성하는 방법에 대해 자세히 알아보려면 **부분 프리렌더링(실험적) 문서**를 참조하거나 **부분 프리렌더링 템플릿 및 데모**를 시도해보세요. 이 기능은 **실험적**이며 **아직 프로덕션 배포에 적합하지 않음**을 유의하세요.
> <https://nextjs.org/docs/app/api-reference/next-config-js/partial-prerendering>  
> <https://vercel.com/templates/next.js/partial-prerendering-nextjs>

---

## 요약 - Summary

요약하자면, 애플리케이션에서 데이터 페칭을 최적화하기 위해 몇 가지 작업을 수행했습니다. 여러분은:

1. 서버와 데이터베이스 간의 지연 시간을 줄이기 위해 애플리케이션 코드와 같은 지역에 데이터베이스를 생성했습니다.
2. React Server Components로 서버에서 데이터를 가져왔습니다. 이를 통해 비용이 많이 드는 데이터 페칭과 로직을 서버에 유지하고, 클라이언트 측 JavaScript 번들을 줄이며, 데이터베이스 비밀을 클라이언트에 노출되지 않게 합니다. 
3. 필요한 데이터만 가져오기 위해 SQL을 사용하여 각 요청에 대해 전송되는 데이터 양을 줄이고, 메모리 내에서 데이터를 변환하는 데 필요한 JavaScript 양을 줄였습니다. 
4. 의미가 있을 때 JavaScript로 데이터 페칭을 병렬화했습니다. 5. 느린 데이터 요청이 전체 페이지를 차단하지 않도록 스트리밍을 구현하고, 사용자가 모든 것이 로드될 때까지 기다리지 않고도 UI와 상호작용을 시작할 수 있도록 했습니다. 
6. 데이터 페칭을 필요로 하는 컴포넌트로 이동시켜 라우트의 어떤 부분이 동적이어야 하는지를 분리했습니다.

다음 장에서는 데이터를 가져올 때 구현해야 할 두 가지 일반적인 패턴인 검색과 페이지네이션을 살펴보겠습니다.
